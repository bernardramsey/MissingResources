import com.android.build.gradle.BaseExtension
import com.android.build.gradle.api.AndroidSourceDirectorySet
import com.android.build.gradle.api.AndroidSourceSet
import org.jetbrains.annotations.Nullable
import org.jetbrains.annotations.NotNull

buildscript {
    ext.kotlin_version = '1.3.21'
    repositories {
        google()
        jcenter()

    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.4.0'
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}

subprojects {
    if (!project.hasProperty("notGenStrings")) {
        afterEvaluate {
            def genTask = task("generateMissingRes") {
                new MissingResGenerator(project).run()
            }
            def cleanTask = task("cleanGeneratedMissingRes", type: Delete) {
                delete MissingResGenerator.getGeneratedMissingResDir(project)
            }
            project.getTasks().preBuild.dependsOn genTask
            project.getTasks().clean.dependsOn cleanTask
        }
    }
}

class MissingResGenerator implements Runnable {
    private final Project project

    MissingResGenerator(Project project) {
        this.project = project
    }

    @NotNull
    static File getGeneratedMissingResDir(@NotNull Project project) {
        return new File(project.projectDir, "generatedMissingRes/")
    }

    @Override
    void run() {
        BaseExtension androidExtension = project.getExtensions().findByName("android")
        if (!androidExtension) {
            return
        }

        androidExtension.sourceSets.forEach {
            File generatedDir = new ConcreteSourceSetGenerator(it, getGeneratedMissingResDir(project))
                    .generateMissingResDir()

            if (generatedDir) {
                it.res.srcDirs += project.files(generatedDir)
            }
        }
    }
}

class ConcreteSourceSetGenerator {
    // ======== constants ========

    static final FileFilter DIRS_FILE_FILTER = new FileFilter() {
        @Override
        boolean accept(File file) {
            return file.isDirectory()
        }
    }
    static final FileFilter XML_FILES_FILE_FILTER = new FileFilter() {
        @Override
        boolean accept(File file) {
            return file.name.endsWith(".xml") && !DIRS_FILE_FILTER.accept(file)
        }
    }
    static final FileFilter NON_DEF_DIRS_FILE_FILTER = new FileFilter() {
        @Override
        boolean accept(File file) {
            return DIRS_FILE_FILTER.accept(file) && file.name.startsWith("values-")
        }
    }

    // ======== fields ========

    @NotNull
    private AndroidSourceSet sourceSet
    @NotNull
    private File missingResRootDir

    private final Map<String, Node> defValues = new HashMap<>()
    private final Map<String, Node> nonDefValues = new HashMap<>()

    // ======== constructors ========

    ConcreteSourceSetGenerator(@NotNull AndroidSourceSet sourceSet, @NotNull File missingResRootDir) {
        this.sourceSet = sourceSet
        this.missingResRootDir = missingResRootDir
    }

    // ======== static methods ========

    private static void parseXmlFile(@Nullable File file, @NotNull Map<String, Node> values) {
        if (file == null || !XML_FILES_FILE_FILTER.accept(file)) {
            return
        }

        def xmlParser = new XmlParser()
        def root = xmlParser.parse(file)
        root.children()
                .forEach {
            values.put(it.@name, it)
        }
    }

    private static void writeValuesToFile(@NotNull Map<String, Node> values, @NotNull File file) {
        Node root = new Node(null, "resources")
        values.entrySet().forEach {
            root.append(it.value.clone())
        }

        def printer = new XmlNodePrinter(new PrintWriter(file))
        printer.setPreserveWhitespace(true)
        printer.print(root)
    }

    // ======== methods ========

    @Nullable
    File generateMissingResDir() {
        sourceSet.res.srcDirs.forEach {
            processResDir(it)
        }

        Map<String, Node> missingVales = new HashMap<>(nonDefValues)
        missingVales.keySet().removeAll(defValues.keySet())

        if (missingVales.isEmpty()) {
            return null
        }

        File missingResDir = new File(missingResRootDir, sourceSet.name)

        File missingValuesDir = new File(missingResDir, "values/")
        missingValuesDir.mkdirs()

        File missingValuesFile = new File(missingValuesDir, "values.xml")
        writeValuesToFile(missingVales, missingValuesFile)

        return missingResDir
    }

    private void processResDir(File resDir) {
        if (!resDir.exists() || !resDir.isDirectory()) {
            return
        }

        File[] nonDefValuesDirs = resDir.listFiles(NON_DEF_DIRS_FILE_FILTER)
        if (nonDefValuesDirs.length == 0) {
            return
        }

        nonDefValuesDirs.each {
            it.listFiles(XML_FILES_FILE_FILTER).each {
                parseXmlFile(it, nonDefValues)
            }
        }

        File defValuesDir = new File(resDir, "values/")
        if (!defValuesDir.exists()) {
            return
        }

        defValuesDir.listFiles(XML_FILES_FILE_FILTER).each {
            parseXmlFile(it, defValues)
        }
    }
}